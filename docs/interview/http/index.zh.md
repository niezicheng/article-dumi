---
title: HTTP
order: 5
toc: 'menu'
nav:
  title: 知识集锦
  order: 0
---

> 网络接口层、网络层(IP)、运输层(TCP/UDP)、应用层(HTTP/DNS)

![图解](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e043d3a1add2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

## HTTP

[20 分钟助你拿下 HTTP 和 HTTPS，巩固你的 HTTP 知识体系](https://juejin.cn/post/6994629873985650696)

### 301 和 302 的区别

- 301 Moved Permanently(永久重定向)

  被请求的资源已**永久**移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 `URI` 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是**可缓存的**。

- 302 Found(临时重定向)

  请求的资源现在**临时**从不同的 `URI` 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 `Cache-Control` 或 `Expires` 中进行了指定的情况下，这个响应才是可缓存的。

> 字面上的区别就是 `301` 是永久重定向，而 `302` 是临时重定向。
>
> `301`比较常用的场景是使用域名跳转。`302` 用来做临时跳转，比如：未登陆的用户访问用户中心重定向到登录页面。

### 401 授权问题

考虑下面两种情况：

- 优先考虑是否是需要验证,也就是是否需要授权账号和密码等信息;
- 如果是开放的服务器资源, 需要考虑的是是否有防御性的安全策略（浏览器是否阻止某信息传输）;

如：`iOS9.0` 之后, 就统一规定, 对于 `http` 请求, 只有经过苹果认可的证书且是 `https://` 才可以直接通过访问, 如果还是 `http://` 或者不是苹果认可的证书的 `https` 都是不可以直接访问的。所以,通常情况下, 解决这类问题需要事先在 `info.plist` 文件中添加相应的 `ATS` 配置信息。

### GET 和 POST 的区别

- 浏览器在回退时，`GET` 不会重新请求，但是 `POST` 会重新请求
- **缓存**: `GET` 请求会被浏览器主动缓存下来，请求参数会被完整保留在浏览历史记录里，而 `POST` 默认不会。
- **参数**: `GET` 一般明文放在 `URL` 中，因此不安全，`POST` 放在请求体中，更适合传输敏感信息; `GET` 请求在 `URL` 中传递的参数是有长度限制的，而 `POST` 没有。
- **编码**: `GET` 只能进行 `URL` 编码，只能接收 `ASCII` 字符，而 `POST` 没有限制。
- **幂等性**: `GET` 是幂等的，而 `POST` 不是。(幂等表示执行相同的操作，结果也是相同的)
- **TCP 角度**: `GET` 请求会把请求报文一次性发出去，而 `POST` 会分为两个 TCP 数据包(首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分)。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

#### GET 和 POST 报文上的区别误区

> 结论: `GET` 和 `POST` 方法没有实质区别

**说明：**

`GET` 和 `POST` 只是 `HTTP` 协议中两种请求方式，而 `HTTP` 协议是基于 `TCP/IP` 的应用层协议，无论 `GET` 还是 `POST`，用的都是同一个传输层协议，所以在传输上，没有实质上的区别

- 按照规范带参数的报文一般 `GET` 会放在 `URL` 中，而 `POST` 会放在请求体中
- 不按规范来也是可以的, 我们可以在 `URL` 上写参数，然后方法使用 `POST`；也可以在 `Body` 写参数，然后方法使用 `GET`。当然，这需要服务端支持

#### GET 请求传参长度的误区

> `GET` 请求参数的大小存在限制，而 `POST` 请求的参数大小是无限制的

为了明确这个概念，我们必须了解下面几点:

- `HTTP` 协议未规定 `GET` 和 `POST` 的长度限制
- `GET` 的最大长度显示是因为浏览器和 `web` 服务器限制了 `URI` 的长度
- 不同的浏览器和 `WEB` 服务器，限制的最大长度不一样
- 要支持 `IE`，则最大长度为 `2083` byte，若只支持 `Chrome`，则最大长度 `8182` byte

#### POST 方法会产生两个 TCP 数据包误区

- `HTTP` 协议中没有明确说明 `POST` 会产生两个 `TCP` 数据包，而且实际测试(Chrome)发现，`header` 和 `body` 不会分开发送；所以，`header` 和 `body` 分开发送是部分浏览器或框架的请求方法，不属于 `post` 必然行为
- `RFC` 里描述：`100 continue` 只有在请求里带了 `Expect: 100-continue` 请求头的时候才有意义

> When the request contains an Expect header field that includes a 100-continue expectation, the 100 response indicates that the server wishes to receive the request payload body, as described in Section 5.1.1. The client ought to continue sending the request and discard the 100 response. If the request did not contain an Expect header field containing the 100-continue expectation, the client can simply discard this interim response.

**结论：** 因而部分描述：对于 `POST`，浏览器先发送了一个 `Options` 请求，询问服务器是否支持修改的请求头。如果服务器支持，服务器响应 `100 continue`， 不支持服务器响应 `204`；浏览器再发送 `data`，服务器响应 `200 ok`（返回数据）其实是不严谨的

#### POST 方法比 GET 方法安全？

- 从表面上来看，`POST` 比 `GET` 安全，因为 `POST` 数据在地址栏上不可见
- 从传输的角度来说，他们都是不安全的，因为 `HTTP` 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文；要想安全传输，就只有加密，也就是 `HTTPS`

[都 9102 年了，还问 GET 和 POST 的区别](https://segmentfault.com/a/1190000018129846)

[听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？](https://zhuanlan.zhihu.com/p/25028045)

[为什么要禁止除 GET 和 POST 之外的 HTTP 方法？](https://www.freebuf.com/articles/web/172695.html)

### 四种常见的 POST 提交数据方式

- `application/x-www-form-urlencoded` 默认表单数据提交类型
- `multipart/form-data` 表单上传文件数据提交类型
- `application/json` JSON 格式数据提交类型
- `text/xml` XML 格式数据提交类型

[四种常见的 POST 提交数据方式](https://juejin.cn/post/6844903426195718152)

### 为什么要禁止除 GET 和 POST 之外的 HTTP 方法？

- 除 `GET`、`POST` 之外的其它 `HTTP` 方法，其刚性应用场景较少，且禁止它们的方法简单，即实施成本低
- 一旦让低权限用户可以访问这些方法，他们就能够以此向服务器实施有效攻击，即威胁影响大

1. `OPTIONS` 方法，将会造成服务器信息暴露，如中间件版本、支持的 `HTTP` 方法等【允许客户端查看服务器信息】
2. `PUT` 方法，由于 `PUT` 方法自身不带验证机制，利用 `PUT` 方法即可快捷简单地入侵服务器，上传 `Webshell` 或其他恶意文件，从而获取敏感数据或服务器权限【从客户端向服务器传送的数据取代指定文档内容】
3. `DELETE` 方法，利用 `DELETE` 方法可以删除服务器上特定的资源文件，造成恶意攻击【请求服务器删除指定资源】

[为什么要禁止除 GET 和 POST 之外的 HTTP 方法？](https://www.freebuf.com/articles/web/172695.html)

### 公司规定所有接口都用 post 请求，这是为什么？

- `POST` 不会误用缓存
- `POST` 不受 `URL` 长度限制
- `POST` 能够用来获取也可以用来修改

[公司规定所有接口都用 post 请求，这是为什么？](https://www.zhihu.com/question/336797348)

### http 与 https 的区别

- `http` 是一种广泛使用的网络协议，是一个客户端和服务器请求和应答的标准。
- `http` 工作在 `TCP` 协议的 `80` 端口，`https` 工作在 `TCP` 协议的 `443` 端口
- `http` 协议运行在 `TCP` 协议之上，所有的传输内容都是明文，`https` 运行在 `SSL/TLS` 之上，`SSL/TLS` 运行在`TCP` 之上，所有的传输内容都是经过加密的。
- `https` 是以安全为目标的 `http` 通道，是 `http` 的安全版; 是 `http` 加上 `SSL` 层对传输的信息和 `url` 做了一些加密处理，更加安全。

[详细解析 HTTP 与 HTTPS 的区别](https://juejin.cn/post/6844903471565504526)

### 谈谈 https 的原理？为什么 https 能保证安全？

#### 对称加密

- 对称密钥也就是加密和解密使用的是同一个密钥
- 加密密钥信息(加密算法 + 随机数)在传递给对方过程中可能会被篡改和窥视，从而导致信息泄漏

#### 非对称加密

> 解决密钥信息被中途拦截问题

**RSA（非对称加密算法）：** 双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密

**缺点：** `RSA` 算法很慢，导致信息加密过程可能比较慢

#### 非对称加密 + 对称加密

> 解决 `RSA` 算法加密很慢问题（对称加密）; 对称密钥: 可以是浏览器生成的随机数 `pre_random`

- 使用 `RSA` （非对称加密）公钥加密的**对称密钥**，然后在进行传递（RAS 加密密钥）【客户端】
- 使用 `RSA` （非对称加密）私钥解密获取**对称密钥**，后面使用最终密钥进行通信【服务端】
- 获取 `RSA` 公钥过程中可能获取到被篡改的公钥，导致密钥暴露

**缺点：** 中间人可以拦截 `RSA` 公钥进行篡改，导致后面使用**公钥加密**（被篡改）的**对称密钥**中间人可以解密获取

#### 非对称加密 + 对称加密 + 数字签名

> 解决 `RSA` 公钥被中途篡改问题（CA 公证密钥）

消息摘要 = 原始信息（公钥匙、发送者身份等其他信息） + hash 算法

数字签名 = 消息摘要 + CA 私钥加密

数字证书 = 数字签名 + 原始信息（公钥匙、发送者身份等其他信息）

- 使用 `CA` 私钥加密消息摘要生成 `数字签名` 并结合**原始信息** 生成证书一起发送
- 通过 `CA` 对应的公钥解密 `数字签名` 获取消息摘要并与一起发送过来的原始信息（使用相同的 hash 算法加密生成消息摘要）比较（判断信息内容是否被篡改）

[谈谈 HTTPS](https://juejin.cn/post/6844903504046211079)

### SSL/TLS

#### RSA 算法

1. 浏览器发送 `client_random`（客户端生成的随机数）、`TLS` 版本、以及客户端支持的加密方法
2. 服务器确认 `TLS` 版本和双方使用的加密方法，并给出数字证书和 `server random`（服务器生成的随机数）
3. 浏览器确认数字证书有效，然后使用加密算法生产 `Premaster secret` (随机数)，并使用数字证书中的公钥加密发给服务器
4. 服务器使用私钥解密这个被加密的 `Premaster secret` (随机数)
5. 此刻浏览器和服务器都可以有 `client_random`、`server_random` 和 `Premaster secret` 三个随机数，通过这三个随机数计算最终的 `secret`

**图解：**
![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a28591c41cd64dfe8ceac856a9d40fa3~tplv-k3u1fbpfcp-watermark.image)

#### DH 算法(TSL 1.2)

1. 浏览器发送 `client_random`（客户端生成的随机数）、`TLS` 版本、以及客户端支持的加密方法
2. 服务器确认 `TLS` 版本和双方使用的加密方法，并给出数字证书，同时服务器利用私钥将 `client_random`，`server_random`，`server_params` 签名, 生成 `Signature`, 然后将`签名`和 `server_params` 参数也发送给客户端
3. 浏览器确认数字证书和签名有效，并将 `client params` 参数发送给服务器
4. 此刻浏览器和服务器都可以有 `client_random`、`server_random` 和 `pre_random` ( `server_params` 和 `client_params`) 三个随机数，通过这三个随机数计算最终的 `secret` 。

**说明：**

- **pre_random** 通过 `ECDHE` 算法计算出 `pre_random` ，其中传入两个参数 `server_params` 和 `client_params`。(`ECDHE`基于`椭圆曲线离散对数`，这两个参数也称作`椭圆曲线的公钥`)
- **secret** 通过 `client_random`、`server_random` 和 `pre_random` 这个三个数通过一个伪随机数函数来计算出最终的`secret`

**图解：**
![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a6eee0152d64fa693667e9e40d96d0b~tplv-k3u1fbpfcp-watermark.image)

#### TSL 1.3

1. 浏览器向服务器发送 `client_params`，`client_random`，`TLS` 版本和供筛选的加密套件列表。
2. 服务器返回：`server_random`、`server_params`、`TLS` 版本、确定的加密套件方法以及证书。
3. 浏览器接收，先验证数字证书和签名。
4. 现在双方都有 `client_params`、`server_params`，可以根据 `ECDHE` 计算出 `pre_random`。

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da49387029c240cb8b92e0fbc10e819b~tplv-k3u1fbpfcp-watermark.awebp)

[TLS 详解握手流程](https://juejin.cn/post/6895624327896432654)

[图解 SSL/TLS 协议(阮)](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

### HTTP keep-alive

- http 发送请求是否开启 `tcp` 持久连接（持久连接超时后断开连接）
- `http 1.0` 中默认是关闭的，需要在 `http` 头加入 `Connection: Keep-Alive`，才能启用`Keep-Alive`；`http 1.1` 中默认启用 `Keep-Alive`，如果加入 `Connection: close`，才关闭
- 启用 `Keep-Alive` 模式相对而言是更高效，性能更高。因为避免了建立/释放连接的开销（有些服务对持久连接数量有一定的限制，超出后会结束多余数量的连接）
- `RFC` 指出：单用户客户端与任何服务器或代理之间的连接数不应该超过 `2` 个。一个代理与其它服务器或代码之间应该使用不超过 `2 * N` 的活跃并发连接。这是为了提高 `HTTP` 响应时间，避免拥塞（冗余的连接并不能代表执行性能的提升）

[HTTP 协议头部与 Keep-Alive 模式详解](https://byvoid.com/zhs/blog/http-keep-alive-header/)

[HTTP keep-alive 二三事](https://lotabout.me/2019/Things-about-keepalive)

## TCP

[(建议收藏)TCP 协议灵魂之问，巩固你的网路底层基础](https://juejin.cn/post/6844904070889603085)

### TCP 和 UDP 的区别概述

- `TCP` 是一个面向连接的、可靠的、基于字节流的传输层协议。
- `UDP` 是一个面向无连接的传输层协议。

**TCP 三大核心特性:**

- **面向连接:** 通信之前，需要握手建立连接
- **可靠性:** 连接的可靠（有状态、可控制）
  - 有状态: `TCP` 会精准记录哪些数据发送了，被对方接收了和没有被接收到，而且保证数据包按序到达，不允许半点差错
  - 可控制: 当意识到丢包了或者网络环境不佳，`TCP` 会根据具体情况调整自己的行为，控制自己的发送速度或者重发
- **面向字节流:** `TCP` 为了维护状态，将一个个 `IP` 包变成了字节流。而 `UDP` 的数据传输是基于数据报的，这是因为仅仅只是继承了 `IP` 层的特性

[TCP 协议与 UDP 协议的区别](https://zhuanlan.zhihu.com/p/24860273)

### 三次握手

**目的**: 确认双方的`接收能力`和`发送能力`都正常

- 第一次握手：客户端向服务端发送连接请求（向服务器发送连接请求）
- 第二次握手：服务器向客户端发送连接请求，并告诉客户端我已经收到了你的连接请求
- 第三次握手：客户端收到服务器连接请求后，告诉服务器我已经收到了你的连接请求，信息到达服务器后, 二者建立连接

**两次握手情况:**

- 客户端发送连接请求，但因连接请求报文丢失而未收到确认(可能是网络结点长时间滞留了)，客户端再重传一次连接请求
- 服务器收到第二次的连接请求后向客服端发送确认信息，同意建立连接
- 第一次滞留的客户端请求连接可能在双方断开连接后某个时间段到达服务器，由于是两次握手，服务端只要接收到，然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了

#### TFC（TCP Fast Open）握手流程

- 客服端的 `SYN` 增加 `Fast Open Cookie` 请求的 `TCP` 选项发送给服务器端（服务端知道它是一个 TFC 请求）
- 服务端通过使用密钥加密客户端的 `IP` 地址生成一个 `Cookie`(Cookie: 可以看做是服务端提供给到客户端的握手凭证)。服务端给客户端发送 `SYN｜ACK` 响应，在响应包的选项中包含了这个 `Cookie`
- 客户端拿到这个 `Cookie` 的值缓存下来, 后面正常完成三次握手

**后面的连接请求:**

- 客户端的握手请求中携带了这个 `Cookie` 凭证，服务端就会检查这个凭证是否有效（对应的 IP 地址是否之前产生过握手行为，且在有效期内）
- 如果有效，服务器就可以向客服端发送响应信息进行通信了，而不需要等到三次握手后

### 四次挥手

- 第一次挥手: 客户端向服务端发送断开连接请求
- 第二次挥手: 服务端接收后告诉客户端已收到，客户端接收到了服务端的确认
- 第三次挥手: 服务器向客户端发送断开连接请求 (必须等到服务端所有的报文都发送完毕了，才告诉客户端我要断开连接)
- 第四次挥手: 客户端接收服务端断开连接消息后发送确认消息给服务端，服务端断开连接

> 客户端需要等待 2 个`MSL`(`Maximum Segment Lifetime`，报文最大生存时间【MSL: 2 分钟】)时间，没有收到服务端的重发请求，表示确认消息已送达，挥手结束；否则，客服端重新向服务端发送确认收到消息

#### 等待 2MSL 的意义

> 如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发（回到第三次挥手，服务端的重发断开连接请求）

- `1 个 MSL` 确保对端(服务器端)断开连接 `ACK` 响应报文可以到达
- `1 个 MSL` 确保四次挥手中主动关闭方(浏览器端)最后的 `ACK` 响应报文最终能达到对端
- 客户端接收服务端断开连接消息后发送确认消息可以到达服务端；服务端未重新发送断开连接请求

**报文标识字段：**

1. SYN：同步连接序号，`TCP SYN` 报文就是把这个标志设置为 `1`，来请求建立连接；
2. ACK：请求/应答状态。`0` 为请求，`1` 为应答；
3. FIN：结束连线。如果 `FIN` 为 `0` 是结束连线请求，FIN 为 1 表示结束连线；
4. RST：连线复位，首先断开连接，然后重建；
5. PSH：通知协议栈尽快把 `TCP` 数据提交给上层程序处理。

### TCP 的流量控制？

[流量控制](https://juejin.cn/post/6844904070889603085#heading-38)

### TCP 的拥塞控制

[拥塞控制](https://juejin.cn/post/6844904070889603085#heading-43)

## CDN

1. 引入 `CDN` 后，用户访问网站的基本流程

- 当用户点击网站页面上的内容 `URL`，先经过本地 `DNS` 系统解析，如果本地 `DNS` 服务器没有相应域名的缓存，则本地 `DNS` 系统会将域名的解析权交给 `CNAME` 指向的 `CDN` 专用 `DNS` 服务器
- `CDN` 的 `DNS` 服务器将 `CDN` 的全局负载均衡设备 `IP` 地址返回给用户
- 用户向 `CDN` 的全局负载均衡设备发起 `URL` 访问请求
- `CDN` 全局负载均衡设备根据用户 `IP` 地址，以及用户请求的 `URL`，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上

2. 基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的 `IP` 地址，最终将得到的 `IP` 地址返回给全局负载均衡设备:

- 根据用户 `IP` 地址，判断哪一个边缘节点距用户最近
- 根据用户所请求的 `URL` 中携带的内容名称，判断哪一个边缘节点上有用户所需内容
- 查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力
- 全局负载均衡设备把服务器的 `IP` 地址返回给用户，用户向最优的缓存服务器发送请求，然后获取响应数据信息

3. CDN 回源

- 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地

[漫话：如何给女朋友解释什么是 CDN？](https://juejin.cn/post/6844903906296725518)

## 拓展

[HTTP 发展史（HTTP1.1，HTTPS，SPDY，HTTP2.0，QUIC，HTTP3.0）](https://juejin.cn/post/6844903988953874445)

[一文读懂 HTTP/1、HTTP/2、HTTP/3](https://network.51cto.com/art/202003/612101.htm)

[浅谈 HTTP/2 Server Push](https://zhuanlan.zhihu.com/p/26757514)
